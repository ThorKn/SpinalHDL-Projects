import os

def mult(a, b):
    l = len(a)

    # recursion end at 16 bit (2 bytes)
    if (l == 2):
        result = (int.from_bytes(a, byteorder = 'big')*int.from_bytes(b, byteorder = 'big')).to_bytes(4, byteorder = 'big')
        return result

    ah = a[0:int(l/2)]
    al = a[int(l/2): l]
    bh = b[0:int(l/2)]
    bl = b[int(l/2): l]

    ahl_int = (int.from_bytes(al, byteorder = 'big') - int.from_bytes(ah, byteorder = 'big'))
    ahl = abs(ahl_int).to_bytes(int(l/2), byteorder = 'big')
    bhl_int = (int.from_bytes(bh, byteorder = 'big') - int.from_bytes(bl, byteorder = 'big'))
    bhl = abs(bhl_int).to_bytes(int(l/2), byteorder = 'big')

    p1 = mult(ah, bh)
    p2 = mult(al, bl)
    p3 = mult(ahl, bhl)
    # if ((ahl_int < 0) ^ (bhl_int < 0)):
    #    p3_int = -(int.from_bytes(p3, byteorder = 'big'))
    #else:
    p3_int = int.from_bytes(p3, byteorder = 'big')

    result_m = (p3_int + int.from_bytes(p1, byteorder = 'big')
                +int.from_bytes(p2, byteorder = 'big')).to_bytes(l+1, byteorder = 'big')

    result_h_int = int.from_bytes(p1, 'big') << (l*8)
    result_m_int = int.from_bytes(result_m, 'big') << (int(l/2)*8)
    result_l_int = int.from_bytes(p2, 'big')

    result = (result_h_int + result_m_int + result_l_int).to_bytes((l*2), 'big')
    return result

counter = 0
for i in range(1):
    a = bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])
    b = bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])
    """
    a = os.urandom(128)
    b = os.urandom(128)

    a = bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])
    b = bytearray([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
                   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF])
    """
    result = int.from_bytes(mult(a,b), byteorder = 'big')
    print(result.to_bytes(16, 'big').hex())

    check_result = int.from_bytes(a, 'big')*int.from_bytes(b, 'big')
    print(check_result)

    if (result == check_result):
        counter += 1
    else:
        print("Calculation FAILED")
        break;

print("Correct calcs: " + str(counter))
